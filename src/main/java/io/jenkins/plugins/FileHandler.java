package io.jenkins.plugins;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;

import hudson.model.BuildListener;
import hudson.model.Result;
import hudson.model.Run;
import hudson.util.Secret;
import org.json.JSONArray;
import org.json.JSONObject;

public class FileHandler {

    private String fileName;
    private String filePath;
    private String artifactPath;
    private String content;
    private String blacklistFileName = "blacklist.json";
    private ArrayList<Vulnerability> vulnerabilities;
    private long epoch;

    private String url;
    private String username;
    private Secret password;
    private Run run;

    public FileHandler(Run run, String artifactPath, String url, String username, Secret password){
        this.artifactPath = artifactPath.toString() + "docker-compose-files/";
        this.run = run;

        this.fileName = retrieveReportName(this.artifactPath);
        if(this.fileName == ""){
            Result result = Result.FAILURE;
            this.run.setResult(result);
        } else {
            this.epoch = retrieveEpoch(this.fileName);
            this.filePath = this.artifactPath + this.fileName;

            this.url = url;
            this.username = username;
            this.password = password;
        }
    }

    public String getFilePath(){
        return this.filePath;
    }

    /**
     * retrieveReportName retrieves the name of the report generated by security scan.
     * @param workspace, the path where the file resides.
     * @return fileName, the name of the file.
     */
    private String retrieveReportName(String workspace){
        File[] listFiles = new File(workspace).listFiles();

        String fileName = "";
        if(listFiles != null) {
            for (int i = 0; i < listFiles.length; i++) {
                if (listFiles[i].isFile()) {
                    fileName = listFiles[i].getName();
                    if(fileName.contains("neteye_security_audit_report_")){
                        return fileName;
                    }
                }
            }
        } else {
            Result result = Result.FAILURE;
            this.run.setResult(result);
        }
        return fileName;
    }

    /**
     * retrieveEpoch returns the epoch of the security report, which will be used in order to synchronise reports of different builds.
     * @param fileName, the name of the security report
     * @return epoch, the epoch of the security report
     */
    private long retrieveEpoch(String fileName){
        String[] fileParts = fileName.split("_");
        String[] fileEpochString = fileParts[4].split(".json");
        long fileEpoch = Long.parseLong(fileEpochString[0]);

        return fileEpoch;
    }

    /**
     * readContent method saves the content of the last security report in the content variable.
     * @return the content of the last security report
     */
    public String readContent(){
        this.content = "The content is not available!";
        try {
            this.filePath = String.valueOf(this.filePath);
            this.content = new String(Files.readAllBytes(Paths.get(this.filePath)));
            return this.content;
        } catch (IOException e) {
            e.printStackTrace();
        }

        return this.content;
    }

    /**
     * getVulnerabilities method parse the JSON Security report in order to obtain the vulnerability information.
     * Moreover, if a vulnerability is considered false positive by another build, then it is not added in the final vulnerabilities list.
     * @return the list of detected vulnerabilities
     */
    public ArrayList<Vulnerability> getVulnerabilities(){
        this.content = readContent();

        JSONObject json = new JSONObject(this.content);
        JSONObject vulnerabilitiesJSON = json.getJSONObject("vulnerabilities");

        ArrayList<Vulnerability> finalVulnerabilities = new ArrayList<>();

        for(Iterator key = vulnerabilitiesJSON.keys(); key.hasNext();){
            JSONArray vulnerabilitiesList = new JSONArray();
            String vulnerabilityType = key.next().toString();
            vulnerabilitiesList = vulnerabilitiesJSON.getJSONArray(vulnerabilityType);

            JSONArray tmpList = new JSONArray();
            for (int i = 0; i < vulnerabilitiesList.length(); i++){
                Vulnerability vulnerability = new Vulnerability();
                JSONObject jsonVulnerability = vulnerabilitiesList.getJSONObject(i);

                vulnerability.setVulnerabilityType(vulnerabilityType);

                String path = jsonVulnerability.getString("path");
                vulnerability.setVulnerablePath(path);

                String parameter = jsonVulnerability.getString("parameter");
                vulnerability.setVulnerableParameter(parameter);

                JSONObject jsonHTTPRequest = jsonVulnerability.getJSONObject("http_request");

                String attackVector = jsonHTTPRequest.getString("attack_vector");
                vulnerability.setAttackVector(attackVector);

                String method = jsonHTTPRequest.getString("method");
                vulnerability.setHTTPMethod(method);

                String vulnerableURL = jsonHTTPRequest.getString("url");
                vulnerability.setUrl(vulnerableURL);

                getVulnerabilityInformationFromWhiteList(vulnerability, jsonVulnerability);
                if(vulnerability.getStatus() == null){
                    vulnerability.setStatus("Not confirmed");
                }

                JSONObject parameters = jsonHTTPRequest.getJSONObject("parameter_list");
                ArrayList<ParameterEntry> parameterList = new ArrayList<>();

                for(Iterator parameterKeys = parameters.keys(); parameterKeys.hasNext();){
                    String parameterKey = parameterKeys.next().toString();
                    ParameterEntry parameterEntry = new ParameterEntry();

                    if(!parameterKey.equals("")) {
                        parameterEntry.setKey(parameterKey);
                        parameterEntry.setValue((String)parameters.get(parameterKey));
                        parameterList.add(parameterEntry);
                    }
                }
                vulnerability.setParameterList(parameterList);

                DatabaseConnection database = new DatabaseConnection(this.url, this.username, this.password);
                boolean existBlacklistElement = database.checkBlacklistElement(vulnerabilityType, path, parameter, attackVector);

                if(existBlacklistElement){
                    vulnerability.setStatus("In blacklist");
                    vulnerability.setIssueURL(null);
                    vulnerability.setIssueJiraID(null);
                    vulnerability.setIssueRequestID(null);
                    vulnerability.setHowToReproduce(null);
                    vulnerability.setAffectedVersions(null);
                    vulnerability.setProjectKey(null);
                } else if(vulnerability.getStatus() == null){
                    vulnerability.setStatus("Not confirmed");
                }
                jsonVulnerability.put("status", vulnerability.getStatus());

                finalVulnerabilities.add(vulnerability);
                tmpList.put(jsonVulnerability);
                
                database.closeDBConnection();
            }
            vulnerabilitiesJSON.put(vulnerabilityType, tmpList);
            json.put("vulnerabilities", vulnerabilitiesJSON);
        }

        try {
            FileWriter blacklistFileWriter = new FileWriter(this.filePath);
            blacklistFileWriter.write(json.toString(4));
            blacklistFileWriter.flush();
            blacklistFileWriter.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        this.vulnerabilities = finalVulnerabilities;
        return this.vulnerabilities;
    }

    /**
     * getVulnerabilityInformationFromWhiteList method checks the information in the whitelist table in the DB 
     * in order to retrieve the information of confirmed vulnerabilities.
     * @param vulnerability the vulnerability object where the information is stored 
     * @param jsonVulnerability the JSONObject that contains the information of the vulnerability 
     */
    private void getVulnerabilityInformationFromWhiteList(Vulnerability vulnerability, JSONObject jsonVulnerability){
        String vulnerabilityType = vulnerability.getVulnerabilityType();
        String path = vulnerability.getVulnerablePath();
        String parameter = vulnerability.getVulnerableParameter();
        String method = vulnerability.getHTTPMethod();
        String vulnerableURL = vulnerability.getUrl();

        DatabaseConnection database = new DatabaseConnection(this.url, this.username, this.password);

        boolean existWhitelistElement = database.checkConfirmedElement(vulnerabilityType, path, parameter, method);
        int id = -1;
        if(existWhitelistElement){
            id = database.getIDFromWhitelist(vulnerabilityType, path, parameter, method);
        }
        if(id != -1){
            vulnerability.setStatus("Confirmed");

            String howToReproduce = database.getHowToReproduce(id);
            String projectKey = database.getProjectKey(id);
            String affectedVersions = database.getAffectedVersions(id);
            String requestID = database.getRequestID(id);
            String jiraID = database.getJiraID(id);
            String issueURL = database.getIssueURL(id);

            vulnerability.setHowToReproduce(howToReproduce);
            vulnerability.setProjectKey(projectKey);
            vulnerability.setAffectedVersions(affectedVersions);
            vulnerability.setIssueRequestID(requestID);
            vulnerability.setIssueJiraID(jiraID);
            vulnerability.setIssueURL(issueURL);
        
            long whitelistEpoch = database.getEpochFromWhitelist(id);
            if(whitelistEpoch != epoch){
                jsonVulnerability.put("how_to_reproduce", vulnerability.getHowToReproduce());
                jsonVulnerability.put("status", vulnerability.getStatus());
                String jiraJSON = "{\"project_key\":\"" + vulnerability.getProjectKey() + "\"," +
                        "\"affected_version\":\"" + vulnerability.getAffectedVersions() + "\"," +
                        "\"id_request\":\"" + vulnerability.getIssueRequestID() + "\"," +
                        "\"id_jira\":\"" + vulnerability.getIssueJiraID() + "\"," +
                        "\"issue_url\":\"" + vulnerability.getIssueURL() + "\"}";

                JSONObject jiraInformation = new JSONObject(jiraJSON);
                jsonVulnerability.put("jira_information", jiraInformation);
            }
        }

        database.closeDBConnection();
    }
    
    /**
     * removeBlacklistElementFromSecurityReport removes from the security report the vulnerabilities which are
     * selected as false positives by the user.
     * @param options the array that contains the options for each detected vulnerability
     */
    public void removeBlacklistElementFromSecurityReport(ArrayList<String> options){
        this.content = readContent();
        JSONObject json = new JSONObject(this.content);
        JSONObject vulnerabilitiesJSON = json.getJSONObject("vulnerabilities");

        String vulnerabilityType = "";

        int frontEndIndex = 0;
        for(Iterator vulnerabilityClassKey = vulnerabilitiesJSON.keys(); vulnerabilityClassKey.hasNext();) {
            JSONArray vulnerabilitiesList = new JSONArray();
            vulnerabilityType = vulnerabilityClassKey.next().toString();
            vulnerabilitiesList = vulnerabilitiesJSON.getJSONArray(vulnerabilityType);

            for (int i = 0; i < vulnerabilitiesList.length(); i++) {
                JSONObject jsonVulnerability = vulnerabilitiesList.getJSONObject(i);
                String path = jsonVulnerability.getString("path");
                JSONObject HTTPRequest = jsonVulnerability.getJSONObject("http_request");
                String attackVector = HTTPRequest.getString("attack_vector");
                if (this.vulnerabilities.get(frontEndIndex).getVulnerabilityType().equals(vulnerabilityType) &&
                        this.vulnerabilities.get(frontEndIndex).getVulnerableParameter().equals(jsonVulnerability.getString("parameter")) &&
                        this.vulnerabilities.get(frontEndIndex).getVulnerablePath().equals(path) &&
                        this.vulnerabilities.get(frontEndIndex).getAttackVector().equals(attackVector) &&
                        options.get(frontEndIndex).equals("add_blacklist")) {
                    vulnerabilitiesList.remove(i);
                    i--;
                }
                frontEndIndex++;
            }

            vulnerabilitiesJSON.put(vulnerabilityType, vulnerabilitiesList);
            json.put("vulnerabilities", vulnerabilitiesJSON);
        }

        try {
            FileWriter blacklistFileWriter = new FileWriter(this.filePath);
            blacklistFileWriter.write(json.toString(4));
            blacklistFileWriter.flush();
            blacklistFileWriter.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        System.out.println("Info: Blacklist elements remove from JSON file!");
    }

    /**
     * addHowToReproduceDescriptionInSecurityReport method adds a new key in the security report, called
     * how_to_reproduce. The value of this new key is the content of the textarea written by user.
     * @param actionSteps the array that contains the steps to reproduce vulnerability
     * @param options the array that contains the options for each detected vulnerability
     */
    public void addHowToReproduceDescriptionInSecurityReport(ArrayList<String> actionSteps, ArrayList<String> options) {
        this.content = readContent();
        JSONObject json = new JSONObject(this.content);
        JSONObject vulnerabilitiesJSON = json.getJSONObject("vulnerabilities");

        int frontEndIndex = 0;
        for (Iterator vulnerabilityClassKey = vulnerabilitiesJSON.keys(); vulnerabilityClassKey.hasNext(); ) {
            String vulnerabilityType = vulnerabilityClassKey.next().toString();
            JSONArray vulnerabilitiesList = vulnerabilitiesJSON.getJSONArray(vulnerabilityType);
            JSONArray tmpList =  new JSONArray();
            for (int i = 0; i < vulnerabilitiesList.length(); i++){
                JSONObject jsonVulnerability = vulnerabilitiesList.getJSONObject(i);
                if(options.get(frontEndIndex).equals("confirmed")){
                    jsonVulnerability.put("how_to_reproduce", actionSteps.get(frontEndIndex));
                    vulnerabilities.get(frontEndIndex).setHowToReproduce(actionSteps.get(frontEndIndex));
                    tmpList.put(jsonVulnerability);
                } else {
                    tmpList.put(jsonVulnerability);
                }
                frontEndIndex++;
            }
            vulnerabilitiesJSON.put(vulnerabilityType, tmpList);
            json.put("vulnerabilities", vulnerabilitiesJSON);
        }

        try {
            FileWriter blacklistFileWriter = new FileWriter(this.filePath);
            blacklistFileWriter.write(json.toString(4));
            blacklistFileWriter.flush();
            blacklistFileWriter.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        System.out.println("Info: Add \"how_to_reproduce\" element in JSON file!");
    }

    /**
     * updateBlacklist method checks if a blacklist element exists in the database,
     * then it adds the new blacklist element in negative case. Otherwise, it does not add anything.
     * @param options the array that contains the options for each detected vulnerability
     */
    public void updateBlacklist(ArrayList<String> options){
        DatabaseConnection database = new DatabaseConnection(this.url, this.username, this.password);

        for(int i = 0; i < options.size(); i++){
            if(options.get(i).equals("add_blacklist")){
                String vulnerabilityType = this.vulnerabilities.get(i).getVulnerabilityType();
                String path = this.vulnerabilities.get(i).getVulnerablePath();
                String parameter = this.vulnerabilities.get(i).getVulnerableParameter();
                String attackVector = this.vulnerabilities.get(i).getAttackVector();
                boolean existBlacklistElement = database.checkBlacklistElement(vulnerabilityType, path, parameter, attackVector);
                if(!existBlacklistElement){
                    database.insertNewBlacklistElement(vulnerabilityType, path, parameter, attackVector, epoch);
                }
            }
        }
        database.closeDBConnection();
    }

    /**
     * updateConfirmedList method checks if a vulnerability is already selected as confirmed bug,
     * hen it adds the new element in the whitelist table in the DB in negative case. Otherwise, it does not add anything.
     * @param options the array that contains the options for each detected vulnerability
     */
    public void updateConfirmedList(ArrayList<String> options){
        DatabaseConnection database = new DatabaseConnection(this.url, this.username, this.password);

        for(int i = 0; i < options.size(); i++){
            if(options.get(i).equals("confirmed")){
                String vulnerabilityType = this.vulnerabilities.get(i).getVulnerabilityType();
                String path = this.vulnerabilities.get(i).getVulnerablePath();
                String parameter = this.vulnerabilities.get(i).getVulnerableParameter();
                String method = this.vulnerabilities.get(i).getHTTPMethod();
                String vulnerableURL = this.vulnerabilities.get(i).getUrl();
                String howToReproduce =  this.vulnerabilities.get(i).getHowToReproduce();
                String projectKey =  this.vulnerabilities.get(i).getProjectKey();
                String affectedVersions =  this.vulnerabilities.get(i).getAffectedVersions();
                String requestID = this.vulnerabilities.get(i).getIssueRequestID();
                String jiraID = this.vulnerabilities.get(i).getIssueJiraID();
                String issueURL = this.vulnerabilities.get(i).getIssueURL();
                boolean existWhitelistElement = database.checkConfirmedElement(vulnerabilityType, path, parameter, method);
                if(!existWhitelistElement){
                    database.insertNewConfirmedElement(vulnerabilityType, path, parameter, method, vulnerableURL, howToReproduce, projectKey, affectedVersions, requestID, jiraID, issueURL, epoch);
                }
            }
        }

        database.closeDBConnection();
    }

    /**
     * updateData method updates all arrayLists in order to not manage blacklist elements
     * @param options the array that contains the options for each detected vulnerability
     * @param actionSteps the array that contains the steps to reproduce vulnerability
     * @param projectKeyArray the array that contains the project keys
     * @param affectedVersionArray the array that contains the affected versions
     */
    public void updateData(ArrayList<String> options, ArrayList<String> actionSteps, ArrayList<String> projectKeyArray, ArrayList<String> affectedVersionArray){
        for(int i = 0; i < vulnerabilities.size(); i++){
            if(options.get(i).equals("add_blacklist")) {
                this.vulnerabilities.remove(i);
                options.remove(i);
                actionSteps.remove(i);
                projectKeyArray.remove(i);
                affectedVersionArray.remove(i);
                i--;
            }
        }
    }

    /**
     * updateStatusInSecurityReport method adds in the JSON security report a new element, called status,
     * which defines the status of the vulnerability. The vulnerability can have two different status: Confirmed or Not confirmed.
     * The Confirmed status defines that the vulnerability is classified as true positive and it is reported on Jira.
     * Instead, the Not confirmed status indicates that the user has not made a decision yet.
     * @param options the array that contains the options for each detected vulnerability
     */
    public void updateStatusInSecurityReport(ArrayList<String> options) {
        this.content = readContent();
        JSONObject json = new JSONObject(this.content);
        JSONObject vulnerabilitiesJSON = json.getJSONObject("vulnerabilities");

        String vulnerabilityType = "";

        int frontEndIndex = 0;
        for (Iterator key = vulnerabilitiesJSON.keys(); key.hasNext(); ) {
            vulnerabilityType = key.next().toString();
            JSONArray vulnerabilitiesList = vulnerabilitiesJSON.getJSONArray(vulnerabilityType);
            JSONArray tmpList =  new JSONArray();
            for (int j = 0; j < vulnerabilitiesList.length(); j++) {
                JSONObject jsonVulnerability = vulnerabilitiesList.getJSONObject(j);
                if (options.get(frontEndIndex).equals("confirmed")) {
                    jsonVulnerability.put("status", "Confirmed");
                    vulnerabilities.get(frontEndIndex).setStatus("Confirmed");
                } else if(options.get(frontEndIndex).equals("no_action")){
                    if(!jsonVulnerability.has("status")) {
                        jsonVulnerability.put("status", "Not confirmed");
                        vulnerabilities.get(frontEndIndex).setStatus("Not confirmed");
                    }
                } else {
                    jsonVulnerability.put("status", "In blacklist");
                    vulnerabilities.get(frontEndIndex).setStatus("In blacklist");
                }
                tmpList.put(jsonVulnerability);
                frontEndIndex ++;
            }
            vulnerabilitiesJSON.put(vulnerabilityType, tmpList);

            json.put("vulnerabilities", vulnerabilitiesJSON);
        }

        try {
            FileWriter blacklistFileWriter = new FileWriter(this.filePath);
            blacklistFileWriter.write(json.toString(4));
            blacklistFileWriter.flush();
            blacklistFileWriter.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * addJiraInformationToSecurityReport method add new elements related to Jira information in the JSON Security report.
     * Information like project key and affected versions.
     * @param projectKey list of project keys
     * @param affectedVersions list of affected versions
     * @param options list of options (i.e. confirmed, blacklist, no actions)
     */
    public void addJiraInformationToSecurityReport(ArrayList<String> projectKey, ArrayList<String> affectedVersions, ArrayList<String> options, ArrayList<String> jiraResponse){
        this.content = readContent();
        JSONObject json = new JSONObject(this.content);
        JSONObject vulnerabilitiesJSON = json.getJSONObject("vulnerabilities");

        int frontEndIndex = 0;
        for (Iterator key = vulnerabilitiesJSON.keys(); key.hasNext(); ) {
            String vulnerabilityType = key.next().toString();
            JSONArray vulnerabilitiesList = vulnerabilitiesJSON.getJSONArray(vulnerabilityType);
            JSONArray tmpList =  new JSONArray();
            for (int j = 0; j < vulnerabilitiesList.length(); j++) {
                JSONObject jsonVulnerability = vulnerabilitiesList.getJSONObject(j);
                if (options.get(frontEndIndex).equals("confirmed") && vulnerabilities.get(frontEndIndex).getProjectKey() == null && !jiraResponse.get(frontEndIndex).equals("")) {
                    JSONObject jsonJiraResponse = new JSONObject(jiraResponse.get(frontEndIndex));
                    String id = jsonJiraResponse.getString("id");
                    String issueId = jsonJiraResponse.getString("key");
                    String issueURL = "https://siwuerthphoenix.atlassian.net/browse/" + issueId;
                    String jiraJSON = "{\"project_key\":\"" + projectKey.get(frontEndIndex) +"\"," +
                            "\"affected_version\":\"" + affectedVersions.get(frontEndIndex) + "\"," +
                            "\"id_request\":\"" + id + "\"," +
                            "\"id_jira\":\"" + issueId + "\"," +
                            "\"issue_url\":\"" + issueURL + "\"}";
                    JSONObject jiraInformation = new JSONObject(jiraJSON);
                    jsonVulnerability.put("jira_information", jiraInformation);
                    vulnerabilities.get(frontEndIndex).setProjectKey(projectKey.get(frontEndIndex));
                    vulnerabilities.get(frontEndIndex).setAffectedVersions(affectedVersions.get(frontEndIndex));
                    vulnerabilities.get(frontEndIndex).setIssueRequestID(id);
                    vulnerabilities.get(frontEndIndex).setIssueJiraID(issueId);
                    vulnerabilities.get(frontEndIndex).setIssueURL(issueURL);
                }
                tmpList.put(jsonVulnerability);
                frontEndIndex ++;
            }
            vulnerabilitiesJSON.put(vulnerabilityType, tmpList);

            json.put("vulnerabilities", vulnerabilitiesJSON);
        }

        try {
            FileWriter blacklistFileWriter = new FileWriter(this.filePath);
            blacklistFileWriter.write(json.toString(4));
            blacklistFileWriter.flush();
            blacklistFileWriter.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
